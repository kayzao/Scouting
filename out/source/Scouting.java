/* autogenerated by Processing revision 1282 on 2022-10-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Scouting extends PApplet {



char[] keyBinds = { 'a', 's', 'd', 'f', //keybinds for auto hits/misses and teleop hits/misses
                    'j', 'k', 'l', ';'};

Hashtable<Character, Boolean> keys = new Hashtable<Character, Boolean>(10); //To prevent unread inputs and other bugs. First 8 match with keyBinds[], then undoBind, then resetBind
Hashtable<Character, Boolean> prevKeys = new Hashtable<Character, Boolean>(10); //to keep track of the key presses from the last frame
String[] names = {"HIGH HIT", "HIGH MISS", "LOW HIT", "LOW MISS"};
char undoBind = 'z'; //keybind to remove 1 from the button last updated
char resetBind = '`'; //keybind to reset all buttons to 0
int mostRecentUpdated = -1;

Button resetButton;
Button[] buttons = new Button[8];

int autoColor = color(50, 255, 100);
int teleColor = color(0, 255, 255);

boolean start = false; 

boolean mouseDown = false;
int pressedX, pressedY;

 public void setup(){
  //fullScreen();
  /* size commented out by preprocessor */;
  frameRate(240);

  for(int i = 0; i < 10; i++){
    if(i < keyBinds.length){
      keys.put(keyBinds[i], false);
    } else {
      if(i == keyBinds.length){
        keys.put(undoBind, false);
      } else {
        keys.put(resetBind, false);
      }
    }
  }
  prevKeys = new Hashtable<Character, Boolean>(keys);
  
  int padding = 45;
  int x = padding;
  int y = padding;
  int w = (width - 5 * padding) / 4;
  int h = (height - 3 * padding) / 2;
  for(int i = 0; i < buttons.length; i++){
    if(i == 4){
      x = padding;
      y += h + padding;
    }
    buttons[i] = new Button(x, y, w, h, keyBinds[i], true);
    buttons[i].setName(names[i % 4]);
    if(i < 4) buttons[i].fillColor = autoColor;
    x += w + padding;
  }
  
  resetButton = new Button(width / 2 - 30, height - 45, 60, 40, resetBind, true);
  resetButton.fillColor = color(255, 0, 0);
  resetButton.showBorder = false;
  resetButton.name = "RESET";
  resetButton.showCount = false;
}

 public void draw(){
  background(220);
  for(int i = 0; i < buttons.length; i++){
    buttons[i].display();
  }
  resetButton.display();
  if(resetButton.getCounter() > 0){
    setup();
  }
  
  Enumeration<Character> keysEnum = keys.keys();
  Enumeration<Character> prevKeysEnum = prevKeys.keys();
  while(keysEnum.hasMoreElements()){
    char k = keysEnum.nextElement();
    char pk = prevKeysEnum.nextElement();
    println(k + " " + pk);
    if(!keys.get(k) && keys.get(k) != prevKeys.get(pk)){
      for(int i = 0; i < buttons.length; i++){
        if(buttons[i].inKey == k){
          if(k == undoBind){
            buttons[mostRecentUpdated].decrementCounter();
            mostRecentUpdated = -1;
          } else {
            buttons[i].incrementCounter();
            mostRecentUpdated = i;
          }
        }
      }
    }
  }

  fill(0);
  textSize(50);
  textAlign(CENTER);
  text("AUTONOMOUS PERIOD", width / 2, 35);
  text("TELE-OPERATED PERIOD", width / 2, height / 2 + 20);
  //text("!!!FOCUS WINDOW!!!", 250, height - 10);
  
  if(!start){
    fill(0, 0, 0, 100);
    rect(0, 0, width, height);
    fill(255);
    textSize(140);
    textAlign(CENTER);
    text("Press SPACE to start", width / 2, height / 2 );
  }
  
  fill(255, 0, 0);
  textSize(20);
  textAlign(RIGHT);
  text(frameRate, width - 5, height - 5);

  prevKeys = new Hashtable<Character, Boolean>(keys);
}

 public void mousePressed(){
  if(!start) return;
  if(!mouseDown){
    mouseDown = true;
    pressedX = mouseX;
    pressedY = mouseY;
  }
}

 public void mouseReleased(){
  if(!start) return;
  
  for(int i = 0; i < buttons.length; i++){
    if(buttons[i].mouseDown() != 0){
      if(buttons[i].mouseDown() == 1){
        buttons[i].incrementCounter();
      } else {
        buttons[i].decrementCounter();
      }
      buttons[i].undoMode = true;
      if(mostRecentUpdated != -1 && mostRecentUpdated != i) buttons[mostRecentUpdated].undoMode = false;
      mostRecentUpdated = i;
      break;
    }
  }
  if(resetButton.mouseDown() != 0){
    resetButton.incrementCounter();
  }
  pressedX = -1;
  pressedY = -1;
  mouseDown = false;
}

 public void keyPressed(){
  if(!start) return;
  for(int i = 0; i < keys.size(); i++){
    if(i < keyBinds.length){
      if(key == keyBinds[i]){
        keys.replace(keyBinds[i], true);
      }
    }
    if(key == undoBind){
      keys.replace(undoBind, true);
    }
    if(key == resetBind){
      keys.replace(resetBind, true);
    }
  }
}
 public void keyReleased(){
  if(start != true && key == ' '){
    start = true;
  }
  if(!start) return;
  for(int i = 0; i < keys.size(); i++){
    if(i < keyBinds.length){
      if(key == keyBinds[i]){
        keys.replace(keyBinds[i], false);
      }
    }
    if(key == undoBind){
      keys.replace(undoBind, false);
    }
    if(key == resetBind){
      keys.replace(resetBind, false);
    }
  }
}

/*
void keyReleased(){
  //println(key + " " + frameCount);
  if(!start && key == ' ') start = true;
  if(key == mostRecentUpdatedBind){
    buttons[mostRecentUpdated].decrementCounter();
  }
  for(int i = 0; i < buttons.length; i++){
    if(buttons[i].getKey() == key){
      buttons[i].incrementCounter();
      buttons[i].lastUpdate = millis();
    }
  }
  if(resetButton.getKey() == key) resetButton.incrementCounter();
}
*/
class Button{
  private int x, y, w, h, counter;
  private String name = "";
  private char inKey;
  final int pressOffset = 40;
  int textSize, rounding, lastUpdate;
  int fillColor = teleColor;
  int textColor = color(0);
  boolean helpMode, undoMode, showCount, showBorder;
  
  public Button(int x, int y, int w, int h, char inKey, boolean enableHelp){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    counter = 0;
    this.inKey = inKey;
    textSize = PApplet.parseInt(w / 4.5f);
    lastUpdate = millis();
    helpMode = enableHelp;
    showCount = true;
    showBorder = true;
  }
  
  public void setName(String name){
    this.name = name;
  }

  public int mouseDown(){
    if(!mouseDown) return 0;
    if(pressedX > x && pressedX < x + w && pressedY > y && pressedY < y + h){
      if(mouseButton == LEFT) return 1;
      if(mouseButton == RIGHT) return 2;
    } 
    return 0;
  }

  public int kbPressed(){
    if(keyPressed){
      if(keys.get(inKey)){
        return 1;
      } else if(keys.get(undoBind) && undoMode){
        return 2;
      }
    }
    return 0;
  }
  
  public void display(){
    rectMode(CORNER);
    if(showBorder){
      strokeWeight(3);
      stroke(255);
    } else {
      noStroke();
    }
    
    fill(fillColor);
    rect(x, y, w, h, rounding);
    fill(textColor);
    textSize(textSize);
    if(showCount){
      textAlign(RIGHT);
      text(counter, x + (w * 0.9f), y + (h * 0.9f));
    }
    textAlign(CENTER);
    text(name, x + 0.5f * w, y + 0.25f * h);
    fill(255, 100, 100);
    text(inKey, x + 0.5f * w, y + 0.5f * h);
    textAlign(LEFT);
    
    if(mouseDown() == 1 || kbPressed() == 1){ //overlays gray cover to shade button
      fill(255, 255, 255, 120);
      rect(x, y, w, h, rounding);
    } else if(mouseDown() == 2 || kbPressed() == 2){ //overlays red cover to shade button
      fill(255, 0, 0, 120);
      rect(x, y, w, h, rounding);
    }
  }

  private void updateCounter(int x){
    counter = max(0, counter + x);
    lastUpdate = millis();
  }

  public void incrementCounter(){
    updateCounter(1);
  }

  public void decrementCounter(){
    updateCounter(-1);
  }
  
  public int getCounter(){
    return counter;
  }
  
  public int getLastUpdated(){
    return lastUpdate;
  }
  
  public char getKey(){
    return inKey;
  }
}


  public void settings() { size(1200, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Scouting" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
